{"status": "success", "message": "", "data": {"updated_schema": {"Project": {"description": "This project, 'Cub3D-lite (Python/pygame)', aims to develop a first-person 3D maze viewer. It utilizes ray-casting techniques to render a pseudo-3D environment composed of walls (with optional textures or shaded solid colors), a flat-colored floor, and a flat-colored ceiling. The system will parse map definitions and configuration from a specified `.cub` file, which includes paths for wall textures and required RGB color definitions for the floor and ceiling. Key functionalities include player movement (W/A/S/D), rotation (arrow keys), pausing the game with the 'P' key, and robust wall collision detection. Comprehensive error handling for invalid map file configurations is included. The application is built entirely using Python 3.x and Pygame 2.x, adhering to strict non-functional requirements for stability, performance (targeting 60 FPS with delta-time movement), and clean resource management. Core data structures like `CubMapFileConfig`, `PlayerState`, and `GameConstants` will define the game's operational parameters, while `CubFileParser` and `PygameEventSystem` will manage external interactions. The `GameWindowComponent`, `RaycastingRendererComponent`, `PlayerInputHandlerComponent`, and `GameLoopComponent` will form the foundational UI and control logic. User stories cover player navigation (including pausing via 'P' key), exploration, clean exit, map visualization, collision detection, file loading, reporting, and game pausing. Non-functional requirements focus on performance, stability, resource management, and validation.", "CoreDataStructures": {"CubMapFileConfig": {"description": "Describes the structure of the configuration parsed from the `.cub` file. Constraints: `F` and `C` are required; RGB components must be within 0-255. The `map` must be fully enclosed by walls. Exactly one `player_spawn` marker (`N`, `S`, `E`, `W`) must exist within the map. Texture paths (`NO`, `SO`, `WE`, `EA`) are optional. If present but the file is missing or unloadable, a solid color fallback must be used.", "declaration": "{\n    \"NO\": \"string | null\",\n    \"SO\": \"string | null\",\n    \"WE\": \"string | null\",\n    \"EA\": \"string | null\",\n    \"F\": { \"R\": \"int\", \"G\": \"int\", \"B\": \"int\" },\n    \"C\": { \"R\": \"int\", \"G\": \"int\", \"B\": \"int\" },\n    \"map\": \"string[]\",\n    \"player_spawn\": {\n        \"x\": \"int\",\n        \"y\": \"int\",\n        \"direction\": \"enum('N', 'S', 'E', 'W')\"\n    }\n}"}, "PlayerState": {"description": "Represents the player's position, orientation, and movement parameters within the 3D environment.", "declaration": "class PlayerState:\n    position: tuple[float, float] # (x, y) coordinates in map units\n    direction_vector: tuple[float, float] # (dx, dy) normalized vector representing player's forward direction\n    plane_vector: tuple[float, float] # (px, py) camera plane vector, perpendicular to direction_vector, defining FOV\n    rotation_angle: float # Radians, typically measured from the positive X axis\n    move_speed: float # Current tunable movement speed, in map units per second\n    rot_speed: float # Current tunable rotation speed, in radians per second\n    collision_radius: float # Small radius around player for collision detection to avoid clipping into walls"}, "GameConstants": {"description": "Defines various constant values used for game mechanics and rendering, allowing for easy tuning.", "declaration": "class GameConstants:\n    WINDOW_WIDTH: int = 1024\n    WINDOW_HEIGHT: int = 768\n    FOV_DEGREES: float = 66.0 # Field of View in degrees\n    MOVE_SPEED_BASE: float = 0.05 # Base units per second for player movement\n    ROT_SPEED_RADIANS_BASE: float = 0.03 # Base radians per frame/second for player rotation\n    COLLISION_RADIUS: float = 0.1 # Player collision radius in map units\n    FPS_TARGET: int = 60 # Target frames per second"}, "RenderOutputSlice": {"description": "Data structure holding information for rendering one vertical strip of a wall, calculated by the raycaster.", "declaration": "class RenderOutputSlice:\n    wall_height_pixels: int # Calculated height of the wall slice on screen\n    draw_start_y: int # Pixel Y-coordinate where the wall slice starts drawing\n    draw_end_y: int # Pixel Y-coordinate where the wall slice ends drawing\n    wall_color_rgb: tuple[int, int, int] # RGB color for the wall, potentially shaded by distance\n    texture_surface: pygame.Surface | None # Optional Pygame surface for the wall texture, if applicable\n    texture_x_coord: float # X-coordinate on the texture (0.0 to 1.0) to sample from for this slice\n    side: enum('N', 'S', 'E', 'W') # Which side of the wall (North, South, East, West) was hit by the ray\n    distance_to_wall: float # Perpendicular distance from player to the wall hit point"}}, "APIEndpoints": {}, "ExternalInterfaces": {"CubFileParser": {"description": "Manages the parsing, validation, and loading of map and configuration data from a `.cub` file.", "body": "Protocol: File system access, text parsing.\nInput: File path (string) provided as `argv[1]` during application launch.\nOutput: A fully populated `CubMapFileConfig` object if parsing and validation are successful.\nError Semantics:\n    - If the specified `.cub` file is not found or is unreadable: Exit with \"Error\\nFile not found/unreadable.\"\n    - If a texture path is declared in the `.cub` file but the corresponding image file is not found or cannot be loaded: Fallback to using a solid color for that specific wall side. A warning may be logged, but the application must NOT error out or crash.\n    - If `F` (floor) or `C` (ceiling) color definitions are missing, malformed, or contain RGB components outside the 0-255 range: Exit with \"Error\\nInvalid F/C color definition.\"\n    - If the map contains duplicate player spawn markers or no player spawn marker: Exit with \"Error\\nInvalid player spawn configuration.\"\n    - If the map is not fully enclosed by walls (e.g., a path to a 'void' space exists, discoverable via flood-fill or boundary checks): Exit with \"Error\\nMap not enclosed.\"\n    - If an unknown or invalid character symbol is encountered within the map grid section: Exit with \"Error\\nUnknown symbol in map.\"\n    - Any other structural or semantic error during parsing of the `.cub` file: Exit with \"Error\\nInvalid .cub file format.\""}, "PygameEventSystem": {"description": "Handles events generated by the Pygame library, including user input (keyboard, mouse) and window management events from the operating system.", "body": "Protocol: Pygame event queue processing (`pygame.event.get()`).\nEvents Handled:\n    - `pygame.QUIT`: Triggers the application's clean exit sequence.\n    - `pygame.KEYDOWN` (ESC key): Triggers the application's clean exit sequence.\n    - `pygame.KEYDOWN` events for W, A, S, D: Update `PlayerState` to initiate corresponding movement (forward, strafe left, backward, strafe right).\n    - `pygame.KEYDOWN` events for LEFT_ARROW, RIGHT_ARROW: Update `PlayerState` to initiate corresponding rotation (left, right).\n    - `pygame.KEYUP` events for W, A, S, D, LEFT_ARROW, RIGHT_ARROW: Update `PlayerState` to stop corresponding movement or rotation.\n    - `pygame.WINDOWEVENT` (specifically `pygame.WINDOWEVENT_FOCUS_GAINED`, `pygame.WINDOWEVENT_FOCUS_LOST`, `pygame.WINDOWEVENT_MINIMIZED`, `pygame.WINDOWEVENT_RESTORED`, `pygame.WINDOWEVENT_RESIZED`): The application must not crash or freeze. Rendering should continue gracefully during focus changes, and frame timing should remain stable during minimize/restore. If resized, the rendering viewport dimensions must be updated to match the new window size."}}, "UserStories": {"US_PlayerMovement": {"description": "As a player, I want to move forward (W), backward (S), strafe left (A), and strafe right (D), and also be able to pause and unpause the game using the 'P' key, so that I can navigate the maze environment and control the game's flow.", "body": "As a player, I want to move forward (W), backward (S), strafe left (A), and strafe right (D), and also be able to pause and unpause the game by pressing the 'P' key, so that I can navigate the maze environment and control the game's flow."}, "US_PlayerRotation": {"description": "A specific user story capturing a functional requirement.", "body": "As a player, I want to rotate my view left (\u2190) and right (\u2192) using the arrow keys, so that I can change my direction and explore the maze. I also want to be able to pause and unpause the game."}, "US_CleanExit": {"description": "A specific user story capturing a functional requirement.", "body": "As a player, I want the application to exit cleanly and release all resources when I press the ESC key or click the window's close (X) button, so that I can stop playing without issues or lingering processes."}, "US_MapRendering": {"description": "A specific user story capturing a functional requirement.", "body": "As a player, I want to see a pseudo-3D visualization of the maze, including walls (with optional textures or shaded solid colors), a flat-colored floor, and a flat-colored ceiling, so that I can visually perceive the game environment."}, "US_WallCollision": {"description": "A specific user story capturing a functional requirement.", "body": "As a player, I want to collide with walls and be prevented from moving through them, using a small collision radius, so that the physical boundaries of the maze are respected."}, "US_CubFileLoading": {"description": "A specific user story capturing a functional requirement.", "body": "As a system operator, I want the application to load the map and configuration data from a specified `.cub` file provided as a command-line argument, so that different maze layouts and visual styles can be applied."}, "US_CubFileValidationReporting": {"description": "A specific user story capturing a functional requirement.", "body": "As a system operator, I want the application to validate the loaded `.cub` file against specified rules and, if invalid, exit immediately while reporting a specific, informative error message to `stderr`, so that I can understand and correct configuration issues."}}, "NonFunctionalRequirements": {"NFR_Performance_TargetFPS": {"description": "A specific non-functional requirement or constraint.", "body": "The application shall achieve and maintain a target frame rate of approximately 60 frames per second (FPS) during gameplay."}, "NFR_Performance_DeltaTimeMovement": {"description": "A specific non-functional requirement or constraint.", "body": "Player movement and rotation speeds shall be calculated using delta-time (time elapsed between frames) to ensure consistent and smooth behavior, independent of fluctuating frame rates."}, "NFR_Stability_UnhandledExceptions": {"description": "A specific non-functional requirement or constraint.", "body": "The application shall be robust against unhandled Python exceptions. All critical operations, especially file I/O, parsing, and rendering, must include appropriate error handling to prevent unexpected crashes."}, "NFR_Stability_CleanShutdown": {"description": "A specific non-functional requirement or constraint.", "body": "Upon receiving a quit signal (ESC key press or window close event), the application shall perform a clean shutdown. This includes properly releasing all Pygame resources (e.g., surfaces, initialized modules), ensuring no open file handles, and terminating any background threads (if any are introduced)."}, "NFR_Robustness_WindowEvents": {"description": "A specific non-functional requirement or constraint.", "body": "The application shall remain stable and continue rendering gracefully during various window events such as gaining/losing focus, minimization, and restoration. It must not crash, freeze, or exhibit unstable frame timing during these transitions."}, "NFR_ResourceManagement_MemoryLeaks": {"description": "A specific non-functional requirement or constraint.", "body": "The application shall not exhibit memory or resource leaks beyond the typical lifecycle management provided by Python's garbage collector. Specific attention should be paid to ensuring file handles are closed immediately after use and Pygame assets are deallocated when no longer needed."}, "NFR_Validation_FastFailExit": {"description": "A specific non-functional requirement or constraint.", "body": "If any critical validation rule (e.g., `.cub` file parsing, map enclosure, player spawn) fails during initialization, the application shall immediately terminate and print a formatted error message (`Error\\n<your message>`) to `stderr` before exiting."}}, "UIComponents": {"GameWindowComponent": {"description": "A specific UI component, screen, or interactive element.", "body": "Description: The primary display window for the game, managed by the Pygame library.\nProperties:\n    - Initial Size: Configurable, specified as 1024x768 pixels.\n    - Resizable: The window must be resizable by the user.\n    - Title: \"Cub3D-lite (Python/pygame)\".\nBehavior:\n    - Initializes the Pygame display module and creates the main window surface.\n    - Actively listens for window close (`pygame.QUIT`) events.\n    - Provides the main drawing surface onto which all game elements are rendered.\n    - Handles `pygame.WINDOWEVENT_RESIZED` to adapt the rendering viewport.\n    - Manages the display update cycle using `pygame.display.flip()` or `pygame.display.update()`."}, "RaycastingRendererComponent": {"description": "A specific UI component, screen, or interactive element.", "body": "Description: Component responsible for drawing the 3D scene, including walls, floor, and ceiling, using the ray-casting algorithm.\nInput:\n    - `PlayerState`: Current player position and orientation.\n    - `CubMapFileConfig`: Map grid, floor/ceiling RGB colors, and loaded wall texture surfaces.\n    - `pygame.Surface`: The target display surface to draw onto.\n    - `GameConstants`: Field of View (FOV), window dimensions, etc.\nOutput: A fully rendered 3D scene drawn onto the provided target surface.\nBehavior:\n    - For each vertical column of pixels across the screen:\n        - Casts a ray from the player's position into the map grid.\n        - Uses a Digital Differential Analyzer (DDA) or a similar algorithm for efficient ray traversal and wall intersection detection.\n        - Calculates the perpendicular distance from the player to the hit wall to correct for fisheye distortion.\n        - Determines the on-screen height of the wall slice based on its distance and the configured FOV.\n        - Applies distance-based shading to wall colors (e.g., using a factor like `1/(1+distance)`) to simulate depth.\n        - Renders the floor and ceiling as solid, flat colors as defined in `CubMapFileConfig.F` and `CubMapFileConfig.C`.\n        - Renders the wall slice:\n            - If the `CubMapFileConfig` specifies a texture for the hit wall side (N/S/E/W) and it was successfully loaded, use the corresponding `pygame.Surface` to render the textured slice.\n            - If no texture is defined for the wall side or texture loading failed, render a solid color (potentially shaded) as a fallback.\n    - Excludes rendering of sprites, minimaps (unless an optional debug minimap is explicitly added and not graded), or other non-wall elements."}, "PlayerInputHandlerComponent": {"description": "A specific UI component, screen, or interactive element.", "body": "Description: Component responsible for processing keyboard input to update the player's movement and rotation.\nInput:\n    - `pygame.event.Event` objects: Raw events from the Pygame event queue.\n    - `PlayerState`: A reference to the mutable player state object to be updated.\n    - `GameConstants`: Tunable speeds (`MOVE_SPEED_BASE`, `ROT_SPEED_RADIANS_BASE`), `COLLISION_RADIUS`.\n    - `CubMapFileConfig`: The map grid for collision detection.\n    - `float`: Delta time (time elapsed since the last frame) for frame-rate independent movement.\nOutput: An updated `PlayerState` reflecting new position, direction vector, and rotation angle.\nBehavior:\n    - Processes `KEYDOWN` and `KEYUP` events for the W, A, S, D keys to manage player translational movement (forward, strafe left, backward, strafe right).\n    - Processes `KEYDOWN` and `KEYUP` events for the LEFT_ARROW and RIGHT_ARROW keys to manage player rotational movement (turn left, turn right).\n    - Calculates new player positions based on active movement inputs, `PlayerState.move_speed`, and delta-time.\n    - Performs collision detection for player movement against map walls:\n        - Uses `PlayerState.collision_radius` to ensure the player does not clip into wall geometry.\n        - Prevents player movement into map cells marked as `1` (wall).\n        - Allows player movement through map cells marked as `0` (empty space).\n        - Treats map cells containing ` ` (space) as `void` or `out-of-bounds` and acts as an impassable wall.\n    - Calculates new player orientation based on active rotation inputs, `PlayerState.rot_speed`, and delta-time."}, "GameLoopComponent": {"description": "A specific UI component, screen, or interactive element.", "body": "Description: The central game loop orchestrating the continuous execution of the application, including frame timing, event processing, state updates, and rendering.\nInput:\n    - `GameWindowComponent`: For display management.\n    - `PlayerInputHandlerComponent`: For processing player controls.\n    - `RaycastingRendererComponent`: For rendering the 3D scene.\n    - `PlayerState`, `CubMapFileConfig`, `GameConstants`: Core game data and parameters.\nOutput: Continuous game execution and display updates until an exit condition is met.\nBehavior:\n    - Initializes necessary Pygame modules (e.g., `pygame.display`, `pygame.time`).\n    - Calls `CubFileParser` to load and validate the `.cub` file configuration and map at startup. If parsing fails, trigger `NFR_Validation_FastFailExit`.\n    - Initializes `PlayerState` based on `CubMapFileConfig.player_spawn`.\n    - Enters a continuous main loop:\n        - Calculates `delta_time` (time elapsed since the previous frame) for frame-rate independent logic.\n        - Processes all `pygame.event.get()` events using `PygameEventSystem` and `PlayerInputHandlerComponent`.\n        - Updates `PlayerState` based on processed input and `delta_time`, incorporating collision detection.\n        - Clears the display surface (e.g., by filling with a background color).\n        - Invokes `RaycastingRendererComponent` to draw the current 3D scene onto the `GameWindowComponent`'s surface.\n        - Updates the entire display using `pygame.display.flip()`.\n        - Manages the frame rate to target `GameConstants.FPS_TARGET` using `pygame.time.Clock.tick()`.\n        - Upon detection of an exit condition (e.g., `pygame.QUIT` event, ESC key press), initiates the clean shutdown procedures described in `NFR_Stability_CleanShutdown`."}}, "TechnologiesInvolved": {"Python3x": {"description": "A Specific Technology used in the project", "body": "The primary programming language for the entire application. Specifically, the project must be developed and run using Python version 3.x (e.g., 3.8, 3.9, etc.)."}, "Pygame2x": {"description": "A Specific Technology used in the project", "body": "The sole third-party library permitted for this project, specifically Pygame version 2.x. It will be used for all aspects of window management, graphics rendering (e.g., creating surfaces, blitting, drawing primitives), event handling (keyboard, mouse, window events), and time management (e.g., frame rate capping, delta-time calculation). No other external libraries from PyPI or other sources are allowed."}, "RayCastingAlgorithm": {"description": "A Specific Technology used in the project", "body": "The core rendering technique to be implemented to generate the pseudo-3D view of the maze. This involves casting rays from the player's perspective into the 2D map grid and rendering vertical slices corresponding to wall intersections. The implementation is expected to utilize common ray-casting optimizations such as the Digital Differential Analyzer (DDA) algorithm for efficient ray traversal."}}}}}}